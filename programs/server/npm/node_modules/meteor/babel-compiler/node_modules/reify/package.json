{
  "_args": [
    [
      {
        "raw": "reify@https://registry.npmjs.org/reify/-/reify-0.11.24.tgz",
        "scope": null,
        "escapedName": "reify",
        "name": "reify",
        "rawSpec": "https://registry.npmjs.org/reify/-/reify-0.11.24.tgz",
        "spec": "https://registry.npmjs.org/reify/-/reify-0.11.24.tgz",
        "type": "remote"
      },
      "/Users/ben/meteor/packages/babel-compiler/.npm/package-new-6bn5xh"
    ]
  ],
  "_from": "reify@>=0.11.18 <0.12.0",
  "_id": "reify@0.11.24",
  "_inCache": true,
  "_location": "/reify",
  "_phantomChildren": {},
  "_requested": {
    "raw": "reify@https://registry.npmjs.org/reify/-/reify-0.11.24.tgz",
    "scope": null,
    "escapedName": "reify",
    "name": "reify",
    "rawSpec": "https://registry.npmjs.org/reify/-/reify-0.11.24.tgz",
    "spec": "https://registry.npmjs.org/reify/-/reify-0.11.24.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/",
    "/babel-plugin-transform-es2015-modules-reify",
    "/meteor-babel"
  ],
  "_resolved": "https://registry.npmjs.org/reify/-/reify-0.11.24.tgz",
  "_shasum": "411fb90bdf55c5fa1bc7d976beb09dc9540189fe",
  "_shrinkwrap": null,
  "_spec": "reify@https://registry.npmjs.org/reify/-/reify-0.11.24.tgz",
  "_where": "/Users/ben/meteor/packages/babel-compiler/.npm/package-new-6bn5xh",
  "author": {
    "name": "Ben Newman",
    "email": "ben@benjamn.com"
  },
  "browser": "lib/empty.js",
  "bugs": {
    "url": "https://github.com/benjamn/reify/issues"
  },
  "dependencies": {
    "acorn": "~5.0.0",
    "minizlib": "^1.0.3",
    "semver": "^5.3.0"
  },
  "description": "Enable ECMAScript 2015 modules in Node today. No caveats. Full stop.",
  "devDependencies": {
    "babel-core": "^6.24.0",
    "babel-plugin-transform-es2015-modules-reify": "^0.11.0",
    "babel-preset-es2015": "^6.24.0",
    "babylon": "^6.17.0",
    "lodash": "^4.17.4",
    "mocha": "~3.3.0",
    "recast": "^0.12.3"
  },
  "engines": {
    "node": ">=4"
  },
  "homepage": "https://github.com/benjamn/reify#readme",
  "keywords": [
    "ecmascript",
    "modules",
    "import",
    "export",
    "commonjs",
    "require",
    "exports",
    "node"
  ],
  "license": "MIT",
  "main": "node/index.js",
  "name": "reify",
  "optionalDependencies": {},
  "readme": "# re&middot;i&middot;fy <sub>_verb, transitive_</sub> &nbsp; [![Build Status](https://travis-ci.org/benjamn/reify.svg?branch=master)](https://travis-ci.org/benjamn/reify) [![Greenkeeper badge](https://badges.greenkeeper.io/benjamn/reify.svg)](https://greenkeeper.io/)\n\n**re&middot;i&middot;fied** <sub>past</sub> &nbsp; **re&middot;i&middot;fies** <sub>present</sub> &nbsp; **re&middot;i&middot;fy&middot;ing** <sub>participle</sub> &nbsp; **re&middot;i&middot;fi&middot;ca&middot;tion** <sub>noun</sub> &nbsp; **re&middot;i&middot;fi&middot;er** <sub>noun</sub>\n\n  1. to make (something abstract) more concrete or real<br>\n     _\"these instincts are, in humans, reified as verbal constructs\"_\n  2. to regard or treat (an idea, concept, etc.) as if having material existence\n  3. **to enable [ECMAScript 2015 modules](http://www.2ality.com/2014/09/es6-modules-final.html) in *any* version of [Node.js](https://nodejs.org)**\n\nUsage\n---\n\n  1. Run `npm install --save reify` in your package or app directory. The\n     `--save` is important because reification only applies to modules in\n     packages that explicitly depend on the `reify` package.\n  2. Call `require(\"reify\")` before importing modules that contain `import`\n     and `export` declarations.\n\nYou can also easily `reify` the Node REPL:\n\n```sh\n% node\n> require(\"reify\")\n{}\n> import { strictEqual } from \"assert\"\n> strictEqual(2 + 2, 5)\nAssertionError: 4 === 5\n    at repl:1:1\n    at REPLServer.defaultEval (repl.js:272:27)\n  ...\n```\n\nHow it works\n---\n\nCode generated by the `reify` compiler relies on a [simple runtime\nAPI](lib/runtime.js) that can be explained through a series of\nexamples. While you do not have to write this API by hand, it is designed\nto be easily human readable and writable, in part because that makes it\neasier to explain.\n\nI will explain the `Module.prototype.watch` method first, then the\n`Module.prototype.export` method after that. Note that this `Module` is\nthe constructor of the CommonJS `module` object, and the `import` and\n`export` methods are custom additions to `Module.prototype`.\n\n### `module.watch(require(id), setters)`\n\nHere we go:\n\n```js\nimport a, { b, c as d } from \"./module\";\n```\n\nbecomes\n\n```js\n// Local symbols are declared as ordinary variables.\nlet a, b, d;\nmodule.watch(require(\"./module\"), {\n  // The keys of this object literal are the names of exported symbols.\n  // The values are setter functions that take new values and update the\n  // local variables.\n  default(value) { a = value; },\n  b(value) { b = value; },\n  c(value) { d = value; },\n});\n```\n\nAll setter functions are called synchronously before `module.watch` returns,\nwith whatever values are immediately available. However, when there are\nimport cycles, some setter functions may be called again, when the exported\nvalues change. Calling these setter functions one or more times is the key\nto implementing [*live bindings*](http://www.2ality.com/2015/07/es6-module-exports.html),\nas required by the ECMAScript 2015 specification.\n\nImporting a namespace object is no different from importing a named\nexport. The name is simply `\"*\"` instead of a legal identifier:\n\n```js\nimport * as utils from \"./utils\";\n```\nbecomes\n```js\nlet utils;\nmodule.watch(require(\"./utils\"), {\n  \"*\"(ns) { utils = ns; }\n});\n```\n\nNote that the `ns` object exposed here is `!== require(\"./utils\")`, but\ninstead a normalized view of the `require(\"./utils\")` object. This\napproach ensures that the actual `exports` object is never exposed to the\ncaller of `module.watch`.\n\nNotice that this compilation strategy works equally well no matter where\nthe `import` declaration appears:\n\n```js\nif (condition) {\n  import { a as b } from \"./c\";\n  console.log(b);\n}\n```\nbecomes\n```js\nif (condition) {\n  let b;\n  module.watch(require(\"./c\"), {\n    a(value) { b = value; }\n  });\n  console.log(b);\n}\n```\n\nSee [`WHY_NEST_IMPORTS.md`](WHY_NEST_IMPORTS.md) for a much more detailed\ndiscussion of why nested `import` declarations are worthwhile.\n\n### `module.export(getters)`\n\nWhat about `export` declarations? One option would be to transform them into\nCommonJS code that updates the `exports` object, since interoperability\nwith Node and CommonJS is certainly a goal of this approach.\n\nHowever, if `Module.prototype.watch` takes a `require(id)` object and a map\nof *setter* functions, then it seems natural for `Module.prototype.export`\nto be method that registers *getter* functions. Given these getter functions,\nwhenever `module.watch(require(id), ...)` is called by a parent module, the\ngetters for the `id` module will run, updating its `module.exports` object, so\nthat the `module.watch` method has access to the latest exported values.\n\nThe `module.export` method is called with a single object literal whose\nkeys are exported symbol names and whose values are getter functions for\nthose exported symbols. So, for example,\n\n```js\nexport const a = \"a\", b = \"b\", ...;\n```\n\nbecomes\n\n```js\nmodule.export({\n  a: () => a,\n  b: () => b,\n  ...\n});\nconst a = \"a\", b = \"b\", ...;\n```\n\nThis code registers getter functions for the variables `a`, `b`, ..., so\nthat `module.watch` can easily retrieve the latest values of those\nvariables at any time. It's important that we register getter functions\nrather than storing computed values, so that other modules always can\nimport the newest values.\n\nExport remapping works, too:\n\n```js\nlet c = 123;\nexport { c as see }\n```\n\nbecomes\n\n```js\nmodule.export({ see: () => c });\nlet c = 123;\n```\n\nNote that the `module.export` call is \"hoisted\" to the top of the block\nwhere it appears. This is safe because the getter functions work equally\nwell anywhere in the scope where the exported variable is declared, and\na good idea because the hoisting ensures the getters are registered as\nearly as possible.\n\nWhat about `export default <expression>` declarations? It would be a\nmistake to defer evaluation of the `default` expression until later, so\nwrapping it in a hoisted getter function is not exactly what we want.\n\nInstead,\n\n```js\nexport default computeDefault();\n```\n\ngets replaced where it is (without any hoisting) by\n\n```js\nmodule.exportDefault(computeDefault());\n```\n\nThe `module.exportDefault` method is just a convenient\n[wrapper](https://github.com/benjamn/reify/blob/d7c27163a77dac184979862f808ef4e88de91ba8/lib/runtime/index.js#L60-L67)\naround `module.export`:\n\n```js\nmodule.exportDefault = function (value) {\n  return this.export({\n    default: function () {\n      return value;\n    }\n  }, true);\n};\n```\n\nThat `true` argument we're passing to `module.export` is a hint that the\nvalue returned by this getter function will never change, which enables\n[some optimizations](https://github.com/benjamn/reify/issues/134) behind\nthe scenes.\n\n### `module.runSetters()`\n\nNow, suppose you change the value of an exported local variable after the\nmodule has finished loading. Then you need to let the module system know\nabout the update, and that's where `module.runSetters` comes in. The\nmodule system calls this method on your behalf whenever a module finishes\nloading, but you can also call it manually, or simply let `reify` generate\ncode that calls `module.runSetters` for you whenever you assign to an\nexported local variable.\n\nCalling `module.runSetters()` with no arguments causes any setters that\ndepend on the current module to be rerun, *but only if the value a setter\nwould receive is different from the last value passed to the setter*.\n\nIf you pass an argument to `module.runSetters`, the value of that argument\nwill be returned as-is, so that you can easily wrap assignment expressions\nwith calls to `module.runSetters`:\n\n```js\nexport let value = 0;\nexport function increment(by) {\n  return value += by;\n};\n```\n\nshould become\n\n```js\nmodule.export({\n  value: () => value,\n  increment: () => increment,\n});\nlet value = 0;\nfunction increment(by) {\n  return module.runSetters(value += by);\n};\n```\n\nNote that `module.runSetters(argument)` does not actually use `argument`.\nHowever, by having `module.runSetters(argument)` return `argument`\nunmodified, we can run setters immediately after the assignment without\ninterfering with evaluation of the larger expression.\n\nBecause `module.runSetters` runs any setters that have new values, it's\nalso useful for potentially risky expressions that are difficult to\nanalyze statically:\n\n```js\nexport let value = 0;\n\nfunction runCommand(command) {\n  // This picks up any new values of any exported local variables that may\n  // have been modified by eval.\n  return module.runSetters(eval(command));\n}\n\nrunCommand(\"value = 1234\");\n```\n\n### `export`s that are really `import`s\n\nWhat about `export ... from \"./module\"` declarations? The key insight here\nis that **`export` declarations with a `from \"...\"` clause are really just\n`import` declarations that update the `exports` object instead of updating\nlocal variables**:\n\n```js\nexport { a, b as c } from \"./module\";\n```\nbecomes\n```js\nmodule.watch(require(\"./module\"), {\n  a(value) { exports.a = value; },\n  b(value) { exports.c = value; },\n});\n```\n\nThis strategy cleanly generalizes to `export * from \"...\"` declarations:\n\n```js\nexport * from \"./module\";\n```\nbecomes\n```js\nmodule.watch(require(\"./module\"), {\n  \"*\"(ns) {\n    Object.assign(exports, ns);\n  }\n});\n```\n\nThough this code gives the basic idea of how `export * from \"...\"` is\nhandled, in reality Reify generates the following code:\n\n```js\nmodule.watch(require(\"./module\"), {\n  \"*\": module.makeNsSetter()\n});\n```\n\nThe `module.makeNsSetter()` method call returns a function that takes a\nnamespace object and copies its properties to `module.exports`. This\nversion is better because\n\n1. the generated code is shorter,\n\n2. it doesn't rely on `Object.assign` (or a polyfill),\n\n3. it can be a little smarter about copying special properties such as\n   getters, and\n\n4. it reliably modifies `module.exports` instead of `exports`.\n\nExporting named namespaces ([proposal](https://github.com/leebyron/ecmascript-export-ns-from)):\n```js\nexport * as ns from \"./module\";\n```\nbecomes\n```js\nmodule.watch(require(\"./module\"), {\n  \"*\"(ns) { exports.ns = ns; }\n});\n```\n\nRe-exporting default exports ([proposal](https://github.com/leebyron/ecmascript-export-default-from)):\n```js\nexport a, { b, c as d } from \"./module\";\n```\nbecomes\n```js\nmodule.watch(require(\"./module\"), {\n  default(value) { exports.a = value; },\n  b(value) { exports.b = value; },\n  c(value) { exports.d = value; }\n});\n```\n\nWhile these examples have not covered every possible syntax for `import`\nand `export` declarations, I hope they provide the intuition necessary to\nimagine how any declaration could be compiled.\n\nWhen I have some time, I hope to implement a [live-compiling text\neditor](https://github.com/benjamn/reify/issues/15) to enable\nexperimentation.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/benjamn/reify.git"
  },
  "scripts": {
    "test": "test/run.sh"
  },
  "version": "0.11.24"
}
